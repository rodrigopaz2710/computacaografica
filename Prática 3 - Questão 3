#include <GL/glut.h>
#include <math.h>
#include <stdbool.h>
#include <stdlib.h>

/* --------- Estado --------- */
static int shoulder = 0, elbow = 0, wrist = 0, finger1 = 0, finger2 = 0;
static float objX = 3.2f, objY = 0.0f;
static bool  objHeld = false;
static float boxX = 3.2f, boxY = -0.6f;
static float boxSize = 0.8f;

/* --------- Geometria (usar as MESMAS em desenho e cinemática) --------- */
static const float L1 = 2.0f;        // comprimento do braço superior
static const float L2 = 2.0f;        // comprimento do antebraço
static const float HAND_ADV = 0.8f;  // avanço da palma a partir do punho (ao longo do +X local)
static const float FINGER_LEN = 0.4f;
static const float FINGER_SEP = 0.2f; // separação vertical entre os dedos (+/- FINGER_SEP/2)

static inline float rad(float d){ return d * 3.1415926535f / 180.0f; }

void init(void){
    glClearColor(0,0,0,0);
    glEnable(GL_DEPTH_TEST);
}

static void drawSolidWithWire(float r, float g, float b){
    glColor3f(r,g,b);   glutSolidCube(1.0f);
    glColor3f(1,1,1);   glutWireCube(1.0f);
}

/* Base canônica a partir de um ângulo absoluto phi */
static void basis(float phi, float *tx, float *ty, float *nx, float *ny){
    float c = cosf(phi), s = sinf(phi);
    if (tx) *tx = c; if (ty) *ty = s;
    if (nx) *nx = -s; if (ny) *ny =  c;
}

/* Pontas dos dedos e centro de pegada no MUNDO (coerente com a geometria usada no desenho) */
static void gripperTips(float *p1x,float *p1y,float *p2x,float *p2y,float *cx,float *cy){
    float thS = rad((float)shoulder);
    float thE = rad((float)elbow);
    float thW = rad((float)wrist);

    /* base do braço no mundo */
    float bx = -1.0f, by = 0.0f;

    /* cotovelo */
    float ex = bx + L1 * cosf(thS);
    float ey = by + L1 * sinf(thS);

    /* punho (fim do antebraço) */
    float wx = ex + L2 * cosf(thS + thE);
    float wy = ey + L2 * sinf(thS + thE);

    /* orientação absoluta da mão */
    float phi = thS + thE + thW;
    float tx,ty,nx,ny; basis(phi,&tx,&ty,&nx,&ny);

    /* bases dos dedos: avança HAND_ADV e desloca ± FINGER_SEP/2 na normal */
    float b1x = wx + HAND_ADV*tx + ( FINGER_SEP*0.5f)*nx;  // dedo superior
    float b1y = wy + HAND_ADV*ty + ( FINGER_SEP*0.5f)*ny;
    float b2x = wx + HAND_ADV*tx - ( FINGER_SEP*0.5f)*nx;  // dedo inferior
    float b2y = wy + HAND_ADV*ty - ( FINGER_SEP*0.5f)*ny;

    /* ângulos absolutos dos dedos */
    float phi1 = phi + rad((float)finger1);
    float phi2 = phi + rad((float)finger2);

    /* pontas dos dedos */
    float t1x = b1x + FINGER_LEN * cosf(phi1);
    float t1y = b1y + FINGER_LEN * sinf(phi1);
    float t2x = b2x + FINGER_LEN * cosf(phi2);
    float t2y = b2y + FINGER_LEN * sinf(phi2);

    if (p1x) *p1x = t1x; if (p1y) *p1y = t1y;
    if (p2x) *p2x = t2x; if (p2y) *p2y = t2y;
    if (cx)  *cx  = 0.5f*(t1x + t2x);
    if (cy)  *cy  = 0.5f*(t1y + t2y);
}

static bool gripperClosed(void){           // limiares amigáveis
    return (finger1 >= 10) && (finger2 <= -10);
}

static bool gripInsideBox(void){
    float cx,cy; gripperTips(NULL,NULL,NULL,NULL,&cx,&cy);
    float hx = fabsf(cx - boxX), hy = fabsf(cy - boxY);
    float half = boxSize * 0.5f * 0.9f;
    return (hx <= half) && (hy <= half);
}

static void tryToggleGrab(void){
    float cx,cy; gripperTips(NULL,NULL,NULL,NULL,&cx,&cy);
    float dx = cx - objX, dy = cy - objY;
    float dist = sqrtf(dx*dx + dy*dy);

    if (!objHeld){
        if (gripperClosed() && dist < 0.45f) objHeld = true;  // pega
    }else{
        if (gripInsideBox() || !gripperClosed()){
            objHeld = false; objX = cx; objY = cy;            // solta
        }
    }
}

void display(void){
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLoadIdentity();
    gluLookAt(0.0, 0.0, 8.0,  0.0, 0.0, 0.0,  0.0, 1.0, 0.0);

    /* caixa (wire) */
    glPushMatrix();
        glTranslatef(boxX, boxY, 0.0f);
        glScalef(boxSize, boxSize, boxSize);
        glColor3f(1.0f, 0.9f, 0.3f);
        glutWireCube(1.0f);
    glPopMatrix();

    /* objeto: segue centro de pegada se estiver preso */
    float cpx,cpy; gripperTips(NULL,NULL,NULL,NULL,&cpx,&cpy);
    glPushMatrix();
        glTranslatef(objHeld ? cpx : objX, objHeld ? cpy : objY, 0.0f);
        glScalef(0.25f, 0.25f, 0.25f);
        drawSolidWithWire(0.2f, 1.0f, 0.3f);
    glPopMatrix();

    /* --------- DESENHO DO BRAÇO (segmentos colados, sem folga) --------- */
    glPushMatrix();                      /* base -> shoulder */
        glTranslatef(-1.0f, 0.0f, 0.0f);
        glRotatef((GLfloat)shoulder, 0.0f, 0.0f, 1.0f);

        /* UPPER ARM (L1): desenha centrado em L1/2 e depois avança L1 */
        glPushMatrix();
            glTranslatef(L1*0.5f, 0.0f, 0.0f);
            glScalef(L1, 0.4f, 1.0f);
            drawSolidWithWire(0.2f, 0.6f, 1.0f);
        glPopMatrix();
        glTranslatef(L1, 0.0f, 0.0f);    /* chega na junta do cotovelo */

        glRotatef((GLfloat)elbow, 0.0f, 0.0f, 1.0f);

        /* FOREARM (L2) */
        glPushMatrix();
            glTranslatef(L2*0.5f, 0.0f, 0.0f);
            glScalef(L2, 0.4f, 1.0f);
            drawSolidWithWire(0.4f, 1.0f, 0.4f);
        glPopMatrix();
        glTranslatef(L2, 0.0f, 0.0f);    /* chega na junta do punho */

        glRotatef((GLfloat)wrist, 0.0f, 0.0f, 1.0f);

        /* PALMA (HAND_ADV): centrada em HAND_ADV/2 a partir do punho */
        glPushMatrix();
            glTranslatef(HAND_ADV*0.5f, 0.0f, 0.0f);
            glScalef(HAND_ADV, 0.3f, 1.0f);
            drawSolidWithWire(1.0f, 0.7f, 0.3f);
        glPopMatrix();

        /* Dedos – bases em (HAND_ADV, ±FINGER_SEP/2) – mesmos parâmetros da cinemática */

        /* dedo superior */
        glPushMatrix();
            glTranslatef(HAND_ADV,  +FINGER_SEP*0.5f, 0.0f); /* base do dedo */
            glRotatef((GLfloat)finger1, 0.0f, 0.0f, 1.0f);
            glTranslatef(FINGER_LEN*0.5f, 0.0f, 0.0f);       /* centro geom. */
            glScalef(FINGER_LEN, 0.1f, 0.3f);
            drawSolidWithWire(1.0f, 0.2f, 0.2f);
        glPopMatrix();

        /* dedo inferior */
        glPushMatrix();
            glTranslatef(HAND_ADV,  -FINGER_SEP*0.5f, 0.0f);
            glRotatef((GLfloat)finger2, 0.0f, 0.0f, 1.0f);
            glTranslatef(FINGER_LEN*0.5f, 0.0f, 0.0f);
            glScalef(FINGER_LEN, 0.1f, 0.3f);
            drawSolidWithWire(1.0f, 0.2f, 0.2f);
        glPopMatrix();

    glPopMatrix(); /* fim braço */

    glutSwapBuffers();
}

void reshape(int w, int h){
    glViewport(0,0,(GLsizei)w,(GLsizei)h);
    glMatrixMode(GL_PROJECTION); glLoadIdentity();
    gluPerspective(65.0, (GLfloat)w/(GLfloat)h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW); glLoadIdentity();
}

void keyboard(unsigned char key, int x, int y){
    switch (key){
        /* juntas */
        case 's': shoulder = (shoulder + 5) % 360; break;
        case 'S': shoulder = (shoulder - 5) % 360; break;
        case 'e': elbow    = (elbow    + 5) % 360; break;
        case 'E': elbow    = (elbow    - 5) % 360; break;
        case 'w': wrist    = (wrist    + 5) % 360; break;
        case 'W': wrist    = (wrist    - 5) % 360; break;

        /* garra */
        case 'f': finger1  = (finger1  + 5); if (finger1>60)  finger1=60;  break;
        case 'F': finger1  = (finger1  - 5); if (finger1<-5)  finger1=-5;  break;
        case 'g': finger2  = (finger2  + 5); if (finger2>5)   finger2=5;   break;
        case 'G': finger2  = (finger2  - 5); if (finger2<-60) finger2=-60; break;

        /* ação */
        case 'p': tryToggleGrab(); break;

        /* reset */
        case 'r':
            shoulder=0; elbow=0; wrist=0; finger1=0; finger2=0;
            objX=3.2f; objY=0.0f; objHeld=false;
            break;

        case 27: exit(0);
    }
    glutPostRedisplay();
}

int main(int argc, char** argv){
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(700, 700);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Braco robo - pegar objeto e colocar na caixa");
    init();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutMainLoop();
    return 0;
}
