#include <GL/glut.h>
#include <stdlib.h>
#include <stdio.h>


static int   maskBits = 0x8;         /* densidade do xadrez: 0x8 (padr√£o) ou 0x1 (mais blocos) */
static float maxUV    = 1.0f;        /* faixa de coordenadas de textura: 1.0 (0..1) ou 10.0 (0..10) */
static GLint wrapMode = GL_REPEAT;   /* GL_REPEAT ou GL_CLAMP */
static GLint filtMin  = GL_NEAREST;  /* GL_NEAREST ou GL_LINEAR */
static GLint filtMag  = GL_NEAREST;

/* ---------- textura gerada proceduralmente ---------- */
#define checkImageWidth  64
#define checkImageHeight 64
static GLubyte checkImage[checkImageHeight][checkImageWidth][4];
static GLuint  texName = 0;

static void makeCheckImage(void)
{
   
    for (int i = 0; i < checkImageHeight; ++i) {
        for (int j = 0; j < checkImageWidth; ++j) {
            int c = ((((i & maskBits) == 0) ^ ((j & maskBits) == 0))) ? 255 : 0;
            checkImage[i][j][0] = (GLubyte)c;
            checkImage[i][j][1] = (GLubyte)c;
            checkImage[i][j][2] = (GLubyte)c;
            checkImage[i][j][3] = (GLubyte)255;
        }
    }
}

static void uploadTexture(void)
{
    if (!texName) glGenTextures(1, &texName);
    glBindTexture(GL_TEXTURE_2D, texName);

  
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrapMode);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrapMode);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filtMin);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filtMag);

    /* imagem */
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA,
                 checkImageWidth, checkImageHeight,
                 0, GL_RGBA, GL_UNSIGNED_BYTE, checkImage);
}


static void init(void)
{
    glClearColor(0,0,0,0);
    glShadeModel(GL_FLAT);
    glEnable(GL_DEPTH_TEST);

    makeCheckImage();
    uploadTexture();
}

static void drawSingleQuad(void)
{
    /* um unico quadrado (o da esquerda), agora perfeito 2x2 em NDC */
    glBegin(GL_QUADS);
        glTexCoord2f(0.0f,    0.0f   ); glVertex3f(-2.0f, -1.0f,  0.0f);
        glTexCoord2f(0.0f,    maxUV ); glVertex3f(-2.0f,  1.0f,  0.0f);
        glTexCoord2f(maxUV,   maxUV ); glVertex3f( 0.0f,  1.0f,  0.0f);
        glTexCoord2f(maxUV,   0.0f  ); glVertex3f( 0.0f, -1.0f,  0.0f);
    glEnd();
}

static void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glEnable(GL_TEXTURE_2D);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glBindTexture(GL_TEXTURE_2D, texName);

    drawSingleQuad();

    glDisable(GL_TEXTURE_2D);
    glFlush();
}

static void reshape(int w, int h)
{
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat)w/(GLfloat)h, 1.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0f, 0.0f, -3.6f);
}

static void applyAndRefresh(void)
{
    makeCheckImage();
    uploadTexture();
    glutPostRedisplay();
}

static void keyboard(unsigned char key, int x, int y)
{
    switch (key) {
        case '1':  maskBits = 0x1;  applyAndRefresh(); break; /* mais quadrados */
        case '8':  maskBits = 0x8;  applyAndRefresh(); break; /* padrao */
        case 'N': case 'n': filtMin = filtMag = GL_NEAREST; applyAndRefresh(); break;
        case 'L': case 'l': filtMin = filtMag = GL_LINEAR;  applyAndRefresh(); break;
        case 'R': case 'r': maxUV = 1.0f;  glutPostRedisplay(); break;   /* 0..1 */
        case 'T': case 't': maxUV = 10.0f; glutPostRedisplay(); break;   /* 0..10 */
        case 'P': case 'p': wrapMode = GL_REPEAT; applyAndRefresh(); break;
        case 'C': case 'c': wrapMode = GL_CLAMP;  applyAndRefresh(); break;
        case 27:  exit(0); break;
        default: break;
    }
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(600, 450);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("checker.c - texturas: repeticao, filtro e clamp");
    init();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    glutMainLoop();
    return 0;
}
