#include <GL/glut.h>  
#include <stdlib.h>
#include <stdio.h>

/* --- Estado do exercício 3 (sombreamento) --- */
static GLenum gShade = GL_FLAT; /* começa em FLAT como pede o enunciado */
static int slices = 40, stacks = 32; /* pode aumentar para “suavizar” no FLAT */
static int winId = 0;

/* FPS simples */
static int frames = 0;
static int last_ms = 0;
static float fps = 0.f;

/*  Inicializa material, fontes de luz e z-buffer  (mantidas da sua versão) */
void init(void)
{
    /* Material */
    GLfloat mat_ambient[]   = { 0.2f, 0.2f, 0.2f, 1.0f };
    GLfloat mat_diffuse[]   = { 0.8f, 0.8f, 0.8f, 1.0f };
    GLfloat mat_specular[]  = { 1.0f, 1.0f, 1.0f, 1.0f };
    GLfloat mat_shininess[] = { 50.0f };

    glMaterialfv(GL_FRONT, GL_AMBIENT,   mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE,   mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR,  mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    /* Luz 0 posicional vermelha */
    GLfloat light0_ambient[]  = { 0.10f, 0.00f, 0.00f, 1.0f };
    GLfloat light0_diffuse[]  = { 1.00f, 0.00f, 0.00f, 1.0f };
    GLfloat light0_specular[] = { 1.00f, 0.30f, 0.30f, 1.0f };
    GLfloat light0_position[] = { 1.0f, 1.0f, 1.0f, 1.0f };

    glLightfv(GL_LIGHT0, GL_AMBIENT,  light0_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE,  light0_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light0_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light0_position);

    /* Luz 1 spotlight verde da esquerda */
    GLfloat light1_ambient[]   = { 0.0f, 0.05f, 0.0f, 1.0f };
    GLfloat light1_diffuse[]   = { 0.0f, 1.00f, 0.0f, 1.0f };
    GLfloat light1_specular[]  = { 0.0f, 1.00f, 0.0f, 1.0f };
    GLfloat light1_position[]  = { -2.0f, 0.2f, 2.0f, 1.0f };
    GLfloat spot_direction[]   = {  1.0f, -0.1f, -2.0f };
    GLfloat spot_cutoff        = 35.0f;
    GLfloat spot_exp           = 15.0f;

    glLightfv(GL_LIGHT1, GL_AMBIENT,   light1_ambient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE,   light1_diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR,  light1_specular);
    glLightfv(GL_LIGHT1, GL_POSITION,  light1_position);
    glLightf (GL_LIGHT1, GL_SPOT_CUTOFF,    spot_cutoff);
    glLightfv(GL_LIGHT1, GL_SPOT_DIRECTION, spot_direction);
    glLightf (GL_LIGHT1, GL_SPOT_EXPONENT,  spot_exp);
    glLightf (GL_LIGHT1, GL_CONSTANT_ATTENUATION,  1.5f);
    glLightf (GL_LIGHT1, GL_LINEAR_ATTENUATION,    0.5f);
    glLightf (GL_LIGHT1, GL_QUADRATIC_ATTENUATION, 0.2f);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHT1);
    glEnable(GL_DEPTH_TEST);

    glClearColor(0.0, 0.0, 0.0, 0.0);

    /* >>> Troca solicitada: iniciar em GL_FLAT (ao invés de GL_SMOOTH) */
    glShadeModel(gShade);
}

static void updateTitle(void)
{
    char title[128];
    snprintf(title, sizeof(title),
             "Sombreamento: %s | slices=%d stacks=%d | FPS=%.1f",
             (gShade == GL_FLAT ? "FLAT" : "SMOOTH"), slices, stacks, fps);
#ifdef FREEGLUT
    glutSetWindowTitle(title);
#else
    glutSetWindow(winId);
    glutSetWindowTitle(title);
#endif
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glShadeModel(gShade);                 /* aplica o modo atual */
    glutSolidSphere(1.0, slices, stacks); /* mais tesselação = “mais suave” em FLAT */

    glFlush();

    /* FPS simples */
    frames++;
    int now = glutGet(GLUT_ELAPSED_TIME);
    if (now - last_ms > 500) { /* atualiza ~2x/s */
        fps = 1000.0f * frames / (float)(now - last_ms);
        frames = 0;
        last_ms = now;
        updateTitle();
    }
}

void reshape (int w, int h)
{
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
        glOrtho(-1.5, 1.5,
                -1.5*(GLfloat)h/(GLfloat)w,
                 1.5*(GLfloat)h/(GLfloat)w,
                -10.0, 10.0);
    else
        glOrtho(-1.5*(GLfloat)w/(GLfloat)h,
                 1.5*(GLfloat)w/(GLfloat)h,
                -1.5, 1.5,
                -10.0, 10.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void keyboard(unsigned char key, int x, int y)
{
    switch (key) {
        case 'f': case 'F':
            gShade = GL_FLAT;
            updateTitle();
            glutPostRedisplay();
            break;
        case 's': case 'S':
            gShade = GL_SMOOTH;
            updateTitle();
            glutPostRedisplay();
            break;

        /* controla tesselação para “suavizar no FLAT” */
        case ']': slices += 4; if (slices > 256) slices = 256; glutPostRedisplay(); break;
        case '[': slices -= 4; if (slices < 8)   slices = 8;   glutPostRedisplay(); break;
        case '.': stacks += 4; if (stacks > 256) stacks = 256; glutPostRedisplay(); break;
        case ',': stacks -= 4; if (stacks < 8)   stacks = 8;   glutPostRedisplay(); break;

        case 'r': case 'R':
            gShade = GL_FLAT; slices = 40; stacks = 32; updateTitle(); glutPostRedisplay(); break;

        case 27: exit(0); break;
        default: break;
    }
}

int main(int argc, char** argv)
{
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
    glutInitWindowSize(500, 500);
    glutInitWindowPosition(100, 100);
    winId = glutCreateWindow("Sombreamento (inicial: FLAT)");
    init();
    updateTitle();
    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutKeyboardFunc(keyboard);
    last_ms = glutGet(GLUT_ELAPSED_TIME);
    glutMainLoop();
    return 0;
}
